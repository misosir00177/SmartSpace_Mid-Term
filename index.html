<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>防災避難所資訊</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <!-- (ECharts removed — this page now focuses on plotting CSV-based shelter/medical/water points) -->
    <!-- ECharts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
    <!-- Mapbox -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", "Noto Sans TC", sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #f9f9f9;
        }

        #mainChart {
            flex: 1.6;
            height: 100%;
            border-right: 2px solid #e0e0e0;
            position: relative; /* allow absolute-positioned controls inside map */
        }

        #rightUpChart, #rightDown {
            width: 100%;
            padding: 10px;
        }

    /* give more vertical room to the top chart and allow the bottom panel to expand */
    #rightUpChart { height: 340px; margin-bottom: 20px; }
        #rightDown { flex: 1; }
    /* give the medical chart a stable height so ECharts can initialize visibly */
    #rightDown-chart { height: 320px; }
        #rightDown {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        #rightDown-left, #rightDown-right {
            flex: 1;
            height: 100%;
            border-radius: 12px;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        #rightUpChart {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 10px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        .map-title {
            position: absolute;
            top: 15px;
            left: 20px;
            background: rgba(255, 255, 255, 0.85);
            padding: 6px 14px;
            border-radius: 8px;
            font-weight: 600;
            color: #A41623;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        /* Floating controls positioned on the map's right-bottom corner */
        .map-controls { 
            position: absolute;
            right: 16px;
            bottom: 16px;
            background: #fff;
            padding: 10px 12px;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            z-index: 6;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            min-width: 160px;
        }
        .map-controls .title { font-weight:700;color:#2b6ea3;margin-right:6px }
        /* layer toggle icon buttons */
        .layer-toggle {
            display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;border:1px solid #eef6fb;background:#fff;cursor:pointer;font-size:13px;color:#2b6ea3;
        }
        .layer-toggle .dot{width:16px;height:16px;border-radius:50%;display:inline-block;flex:0 0 16px}
        .layer-toggle[data-layer="shelter"] .dot{background:#2ca02c}
        .layer-toggle[data-layer="med"] .dot{background:#A41623}
        .layer-toggle[data-layer="water"] .dot{background:#1f77b4}
        .layer-toggle.off{filter:grayscale(100%) opacity(.45);color:#7a8b94}
        /* Tabs for right-side panels */
        .right-tabs {
            display: flex;
            gap: 6px;
            padding: 6px 10px;
            align-items: center;
        }
        .right-tabs button {
            background: transparent;
            border: 1px solid #e6eef6;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            color: #2b6ea3;
            font-weight: 600;
        }
        .right-tabs button.active {
            background: linear-gradient(90deg,#ffd9b3,#ffcc99);
            border-color: #ffb366;
            color: #7a3500;
        }
        /* Panel containers for tab content */
        .panel { display: none; }
        .panel.active { display: block; }
    #shelterPie { height: 420px; width: 100%; }

    /* make panel content breathe a little more */
    #panel-charts { padding: 8px 6px; }
    #panel-stats { padding: 8px 6px; }
    </style>
</head>

<body>
    <div id="mainChart">
        <div class="map-title">避難資源地圖</div>
        <div class="map-controls" aria-hidden="false">
            <div class="title">避難資訊地圖</div>
            <button class="layer-toggle" data-layer="shelter" title="避難所" aria-pressed="true">
                <span class="dot"></span>
                <span class="label">避難所</span>
            </button>
            <button class="layer-toggle" data-layer="med" title="醫療院所" aria-pressed="true">
                <span class="dot"></span>
                <span class="label">醫療</span>
            </button>
            <button class="layer-toggle" data-layer="water" title="飲水機" aria-pressed="true">
                <span class="dot"></span>
                <span class="label">飲水</span>
            </button>
        </div>
    </div>

    <div style="flex: 1; display: flex; flex-direction: column; background: #f5f5f7; padding: 10px; gap:10px;">

        <!-- Tabs to switch between Charts and Statistics -->
        <div class="right-tabs">
            <button data-tab="charts" class="active">綜合統計</button>
            <button data-tab="stats">避難所資訊</button>
        </div>

        <!-- Panel: Charts (existing layout) -->
        <div id="panel-charts" class="panel active">
            <div id="rightUpChart"></div>
            <div id="rightDown" style="display:flex;gap:10px;">
                <div id="rightDown-chart" style="flex:1;padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,0.04)"></div>
            </div>
        </div>

        <!-- Panel: Statistics (pie chart) -->
        <div id="panel-stats" class="panel">
            <div style="background:#fff;border-radius:10px;padding:12px;box-shadow:0 2px 8px rgba(0,0,0,0.04);display:flex;flex-direction:column;gap:12px">
                <div style="font-weight:700;color:#F39C12;margin-bottom:8px">避難所類型統計</div>
                <div id="shelterPie" style="width:100%;height:320px"></div>
                <div style="font-size:12px;color:#666">註：每類別顯示可支援該災害類型的避難所數量（避難所可同時支援多種災害）。</div>
                <div id="rightDown-right" style="width:100%;height:100px;padding:0px;overflow:auto;background:#fff;border-radius:8px;box-shadow:0 1px 6px rgba(0,0,0,0.04)"></div>
            </div>
        </div>
    </div>

    <script>
        // This page now focuses on plotting CSV-sourced points (避難為主題).
        let map = null;

        function loadCSV(path) {
            console.log('Attempting to load CSV:', path);
            return fetch(path)
                .then(res => {
                    if (!res.ok) throw new Error('Failed to fetch ' + path + ' (' + res.status + ')');
                    return res.text();
                })
                .then(text => {
                    try {
                        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true }).data;
                        console.log(`Parsed ${parsed.length} rows from ${path}`);
                        return parsed;
                    } catch (e) {
                        console.error('PapaParse error for', path, e);
                        throw e;
                    }
                });
        }

    // Add markers from CSV rows. label chooses color & popup title.
    // This function now also stores markers in global arrays so they can be toggled on/off.
    const markerStore = { shelter: [], med: [], water: [] };
    // dataStore keeps pairs of { row, marker } so UI lists can access marker for flyTo/openPopup
    const dataStore = { shelter: [], med: [], water: [] };
        function addCSVMarkers(rows, label) {
            if (!map || !rows) return [];
            const bounds = new mapboxgl.LngLatBounds();
            rows.forEach(row => {
                // Parse floats from common column names
                let lng = parseFloat(row.lng || row.LNG || row.Long || row.longitude || '');
                let lat = parseFloat(row.lat || row.LAT || row.Lat || row.latitude || '');

                // If parsing yields NaN, try alternative columns or trimmed values
                if (Number.isNaN(lng) && row.longitude) lng = parseFloat(row.longitude.trim());
                if (Number.isNaN(lat) && row.latitude) lat = parseFloat(row.latitude.trim());

                // Some CSVs have columns mislabeled: values may be in lat,lng order.
                // Detect and swap when needed (e.g., latitude outside [-90,90] or longitude outside [-180,180]).
                const isLatValid = !Number.isNaN(lat) && lat >= -90 && lat <= 90;
                const isLngValid = !Number.isNaN(lng) && lng >= -180 && lng <= 180;
                if (!isLatValid && isLngValid) {
                    // maybe swapped
                    console.warn('Detected invalid lat; attempting swap for row:', row);
                    const maybeLat = lng;
                    const maybeLng = lat;
                    if (!Number.isNaN(maybeLat) && maybeLat >= -90 && maybeLat <= 90 && !Number.isNaN(maybeLng) && maybeLng >= -180 && maybeLng <= 180) {
                        lat = maybeLat;
                        lng = maybeLng;
                        console.log('Swapped lat/lng for row — new lat:', lat, 'new lng:', lng);
                    } else {
                        // still invalid after swap — skip
                        console.error('Invalid coordinates after swap attempt, skipping row:', row);
                        return;
                    }
                }

                // final validation
                if (Number.isNaN(lng) || Number.isNaN(lat) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    // skip invalid coordinates
                    console.warn('Skipping row with invalid coordinates:', { lng, lat, row });
                    return;
                }

                //SECTION color by label
                let color = '#2ca02c'; // default (避難)
                if (/醫療|hospital|clinic/i.test(label)) color = '#A41623';
                if (/飲水|water/i.test(label)) color = '#1f77b4';

                const marker = new mapboxgl.Marker({ color })
                    .setLngLat([lng, lat])
                    .addTo(map);

                // wire marker click to show details and update comparison chart
                try {
                    const el = marker.getElement();
                    el.addEventListener('click', (e) => {
                        // call details + comparison
                        showShelterDetails(row, marker);
                        try { updateComparisonChart(row); } catch(err){console.warn(err)}
                    });
                } catch (e) { /* ignore if can't attach */ }

                const isMedical = /醫療|hospital|clinic/i.test(label);
                const title = isMedical ? (row.placeName || row.name || row.address || label) : (row.name || row.number || row.address || label || '地點');
                const info = [];
                info.push('類型: ' + label);
                if (row.address) info.push('地址: ' + row.address);
                // phone may be present for both medical and other datasets
                if (row.phone || row.call) info.push('電話: ' + (row.phone || row.call));
                if (row.openingHour) info.push('營業/開放: ' + row.openingHour);

                // Medical-specific fields: normalBed, icuBed, placeName
                if (isMedical) {
                    if (row.normalBed !== undefined && row.normalBed !== '') info.push('一般病床: ' + row.normalBed);
                    if (row.icuBed !== undefined && row.icuBed !== '') info.push('加護病床: ' + row.icuBed);
                    
                }

                // If shelter-specific fields exist, show only applicable hazard types (those marked 'Y')
                function yn(val){
                    if (!val) return '-';
                    const v = String(val).trim().toUpperCase();
                    if (v === 'Y' || v === 'YES' || v === 'TRUE' || v === '可') return '可';
                    if (v === 'N' || v === 'NO' || v === 'FALSE' || v === '否') return '否';
                    return val;
                }

                // For shelters, collect only the hazards that are applicable (Y)
                if (!isMedical) {
                    const hazards = [];
                    const isYes = v => {
                        if (v === undefined || v === null) return false;
                        const s = String(v).trim().toUpperCase();
                        return s === 'Y' || s === 'YES' || s === 'TRUE' || s === '可';
                    };
                    if (isYes(row.forFlooding)) hazards.push('水災');
                    if (isYes(row.forEarthquake)) hazards.push('地震');
                    if (isYes(row.forMudslide)) hazards.push('土石流');
                    if (isYes(row.forTsunami)) hazards.push('海嘯');

                    if (hazards.length > 0) {
                        info.push('適用避難類型: ' + hazards.join('、'));
                    }
                }

                if (row.people !== undefined && row.people !== '') info.push('容納人數: ' + row.people);

                const popupHtml = `<div style="font-size:13px"><div style="font-weight:700;color:${color};margin-bottom:4px">${title}</div>${info.join('<br>')}</div>`;
                marker.setPopup(new mapboxgl.Popup({ offset: 12 }).setHTML(popupHtml));
                bounds.extend([lng, lat]);

                // store marker and row for toggling & UI
                const key = /醫療|hospital|clinic/i.test(label) ? 'med' : (/飲水|water/i.test(label) ? 'water' : 'shelter');
                markerStore[key].push(marker);
                dataStore[key].push({ row: row, marker: marker });
            });
            return bounds;
        }

        function createMapAndPlotCSV() {
            mapboxgl.accessToken = 'pk.eyJ1IjoiYmlhYm9ibyIsImEiOiJjamVvejdlNXQxZnBuMndtdWhiZHRuaTNpIn0.PIS9wtUxm_rz_IzF2WFD1g';
            map = new mapboxgl.Map({
                container: 'mainChart',
                style: 'mapbox://styles/mapbox/light-v11',
                center: [121.6405, 25.0768],
                zoom: 11
            });
            // Wait for map to be ready before adding markers
            map.on('load', () => {
                console.log('Map loaded — now loading CSVs');

                // --- Daan district mask + highlight setup ---
                // Try to fetch an accurate 大安區 polygon from Nominatim (OpenStreetMap)
                const daanNominatimUrl = 'https://nominatim.openstreetmap.org/search.php?q=%E5%A4%A7%E5%AE%89%E5%8D%80+%E5%8F%B0%E5%8C%97&format=geojson&polygon_geojson=1';

                // fallback rectangle if fetch fails
                const fallbackCoords = [[
                    [121.5250, 25.0000],
                    [121.5250, 25.0600],
                    [121.5650, 25.0600],
                    [121.5650, 25.0000],
                    [121.5250, 25.0000]
                ]];

                fetch(daanNominatimUrl)
                    .then(r => r.json())
                    .then(geo => {
                        try {
                            const feat = geo.features && geo.features[0];
                            let polygonCoords = fallbackCoords;
                            if (feat && feat.geometry) {
                                if (feat.geometry.type === 'MultiPolygon') polygonCoords = feat.geometry.coordinates[0];
                                else polygonCoords = feat.geometry.coordinates;
                            }

                            const daanPolygon = {
                                type: 'Feature',
                                properties: { name: '大安區' },
                                geometry: { type: 'Polygon', coordinates: polygonCoords }
                            };

                            // world polygon outer ring
                            const worldOuter = [
                                [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
                            ];
                            const maskPolygon = {
                                type: 'Feature',
                                properties: {},
                                geometry: { type: 'Polygon', coordinates: [worldOuter].concat(polygonCoords) }
                            };

                            if (!map.getSource('daan-mask')) {
                                map.addSource('daan-mask', { type: 'geojson', data: maskPolygon });
                                map.addLayer({
                                    id: 'mask-fill',
                                    type: 'fill',
                                    source: 'daan-mask',
                                    layout: {},
                                    paint: {
                                        'fill-color': 'rgba(230,230,230,0.85)',
                                        'fill-opacity': 1
                                    }
                                });
                            }

                            if (!map.getSource('daan')) {
                                map.addSource('daan', { type: 'geojson', data: daanPolygon });
                                map.addLayer({
                                    id: 'daan-fill',
                                    type: 'fill',
                                    source: 'daan',
                                    layout: {},
                                    paint: { 'fill-color': 'rgba(164,22,35,0.08)', 'fill-opacity': 1 }
                                });
                                map.addLayer({
                                    id: 'daan-line',
                                    type: 'line',
                                    source: 'daan',
                                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                                    paint: { 'line-color': '#A41623', 'line-width': 2, 'line-dasharray': [2,2] }
                                });
                            }
                        } catch (e) {
                            console.warn('Error applying fetched Daan geometry, falling back to rectangle', e);
                        }
                    }).catch(err => {
                        // fallback to rectangle if network fails
                        console.warn('Failed to fetch Daan GeoJSON, using fallback rectangle', err);
                        const polygonCoords = fallbackCoords;
                        const daanPolygon = {
                            type: 'Feature',
                            properties: { name: '大安區' },
                            geometry: { type: 'Polygon', coordinates: polygonCoords }
                        };
                        const worldOuter = [
                            [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
                        ];
                        const maskPolygon = {
                            type: 'Feature',
                            properties: {},
                            geometry: { type: 'Polygon', coordinates: [worldOuter].concat(polygonCoords) }
                        };
                        try {
                            if (!map.getSource('daan-mask')) {
                                map.addSource('daan-mask', { type: 'geojson', data: maskPolygon });
                                map.addLayer({ id: 'mask-fill', type: 'fill', source: 'daan-mask', layout: {}, paint: { 'fill-color': 'rgba(230,230,230,0.85)', 'fill-opacity': 1 } });
                            }
                            if (!map.getSource('daan')) {
                                map.addSource('daan', { type: 'geojson', data: daanPolygon });
                                map.addLayer({ id: 'daan-fill', type: 'fill', source: 'daan', layout: {}, paint: { 'fill-color': 'rgba(164,22,35,0.08)', 'fill-opacity': 1 } });
                                map.addLayer({ id: 'daan-line', type: 'line', source: 'daan', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: { 'line-color': '#A41623', 'line-width': 2, 'line-dasharray': [2,2] } });
                            }
                        } catch(e) { console.warn('fallback map layer error', e); }
                    });

                // --- end Daan setup ---

                Promise.all([
                    loadCSV('ref/DaanMedical.csv'),
                    loadCSV('ref/DaanShelter.csv'),
                    loadCSV('ref/DaanWaterserver.csv')
                ]).then(([med, shelter, water]) => {
                    // We care about shelters primarily, but still show medical & water points with different colors.
                    const boundsList = [];
                    const b1 = addCSVMarkers(shelter, '避難收容');
                    if (b1 && !b1.isEmpty()) boundsList.push(b1);
                    const b2 = addCSVMarkers(med, '醫療機構');
                    if (b2 && !b2.isEmpty()) boundsList.push(b2);
                    const b3 = addCSVMarkers(water, '飲水機');
                    if (b3 && !b3.isEmpty()) boundsList.push(b3);

                    // Fit map to combined bounds if any markers exist
                    if (boundsList.length > 0) {
                        const combined = boundsList.reduce((acc, b) => acc.extend(b), boundsList[0]);
                        map.fitBounds(combined, { padding: 40 });
                    } else {
                        console.warn('No marker bounds found — check parsed CSV rows and lng/lat columns');
                    }

                            // render charts & setup UI
                            try {
                                renderRightPanelCharts(med, shelter, water);
                                setupLayerToggles();
                                // render shelter list (uses dataStore populated by addCSVMarkers)
                                renderShelterList();
                                // render statistics pie (counts by disaster type)
                                try { renderShelterTypePie(); } catch(e){ console.warn('pie render failed', e); }
                            } catch (e) { console.error('Error rendering right panel', e); }
                }).catch(err => console.error('CSV load error', err));
            });
        }

        // Render the right-side charts and cards using ECharts + HTML
        function renderRightPanelCharts(med, shelter, water) {
            // RightUpChart: shelter capacity (top 5)
            try {
                // store parsed shelter data globally so we can update the chart on interactions
                window._shelterChartData = shelter.map(r => ({
                        name: r.name || r.number || (r.address ? r.address.split(',')[0] : '避難所'),
                        people: parseInt(String(r.people || '0').replace(/,/g, '')) || 0,
                        _row: r
                    })).sort((a, b) => b.people - a.people);

                    // initialize top chart and save reference globally for updates
                    window.charts = window.charts || {};
                        const upChart = echarts.init(document.getElementById('rightUpChart'));
                        window.charts.upChart = upChart;
                    // use top 6 shelters for the default view
                    const parsed = (window._shelterChartData || []).slice(0,6);
                    const upOption = {
                        title: { text: '避難所收容人數', left: 'center', textStyle: { color: '#A41623' } },
                        tooltip: {},
                        xAxis: { type: 'category', data: parsed.map(p => p.name), axisLabel: { rotate: 30 } },
                        yAxis: { type: 'value' },
                        series: [{ type: 'bar', data: parsed.map(p => p.people), itemStyle: { color: '#FFB081' } }]
                    };
                    upChart.setOption(upOption);
            } catch (e) { console.warn('shelter chart error', e); }

            // Middle status panel removed — no inline status card. Keep console info for debugging.
            try { console.debug('renderRightPanelCharts: shelter count', shelter.length); } catch(e){console.warn(e)}

            // RightDown-left: medical hospital bed counts (bar chart)
            try {
                const medParsed = med.map(r => ({
                    name: r.placeName || (r.address ? r.address.split(',')[0] : '醫療'),
                    normal: parseInt(String(r.normalBed||'0').replace(/,/g,'')) || 0,
                    icu: parseInt(String(r.icuBed||'0').replace(/,/g,'')) || 0
                })).sort((a,b)=> b.normal - a.normal).slice(0,6);

                const medChart = echarts.init(document.getElementById('rightDown-chart'));
                const medOption = {
                    title: { text: '醫療院所病床數', left: 'center', textStyle:{ color:'#A41623' } },
                    tooltip: { },
                    // place legend centered below the chart to avoid overlapping with bars
                    legend: { data: ['一般病床','加護病床'], bottom: 8, left: 'center' },
                    xAxis: { type: 'category', data: medParsed.map(m=>m.name), axisLabel:{rotate:30} },
                    yAxis: { type: 'value' },
                    series: [
                        { name: '一般病床', type: 'bar', data: medParsed.map(m=>m.normal), itemStyle:{ color:'#A41623'} },
                        { name: '加護病床', type: 'bar', data: medParsed.map(m=>m.icu), itemStyle:{ color:'#A416FF'} }
                    ]
                };
                medChart.setOption(medOption);
                // keep a global reference so we can resize it when tabs change
                window.charts = window.charts || {};
                window.charts.medChart = medChart;
            } catch(e){ console.warn('medical chart error', e); }

            // When charts are first rendered, ensure the top chart shows default ordering
            try { if (window.charts && window.charts.upChart) {
                // default: show top 6 shelters
                updateComparisonChart();
            }} catch(e){console.warn(e)}
        }

        // Update the top chart to compare a selected shelter against others.
        // If selectedRow is undefined, show the default top N list.
        function updateComparisonChart(selectedRow) {
            try {
                const upChart = window.charts && window.charts.upChart;
                if (!upChart || !window._shelterChartData) return;

                const all = window._shelterChartData.slice();
                const selectedName = (selectedRow && (selectedRow.name || selectedRow.number || selectedRow.address)) || null;

                // If a specific row is selected, put it first and then top others (excluding it)
                let list = [];
                if (selectedName) {
                    const sel = all.find(a => {
                        const rname = String(a._row.name || a._row.number || a._row.address || '').toString();
                        return rname && rname.indexOf(selectedName) !== -1 || selectedName.indexOf(rname) !== -1;
                    }) || all.find(a => String(a._row.name||'') === selectedName);
                    if (sel) {
                        list.push(sel);
                        // add next top 5 others
                        const others = all.filter(a => a !== sel).slice(0,5);
                        list = list.concat(others);
                    } else {
                        // fallback to default
                        list = all.slice(0,6);
                    }
                } else {
                    list = all.slice(0,6);
                }

                const names = list.map(l => l.name);
                const values = list.map(l => l.people);

                // color first bar differently if it's the selected one
                const colors = list.map((l, idx) => idx===0 && selectedName ? '#2fa01a' : '#7aff7a');

                const option = {
                    title: { text: '避難所收容人數（比較）', left: 'center', textStyle: { color: '#2ca02c' } },
                    tooltip: {},
                    xAxis: { type: 'category', data: names, axisLabel: { rotate: 30 } },
                    yAxis: { type: 'value' },
                    series: [{ type: 'bar', data: values, itemStyle: { color: function(params){ return colors[params.dataIndex]; } } }]
                };
                upChart.setOption(option, true);
                // store currently-displayed data so clicks can map back to rows
                window.charts = window.charts || {};
                window.charts.upChartData = list;

                // attach click handler: use dataIndex to find the clicked shelter and fly to it
                try {
                    upChart.off('click');
                    upChart.on('click', params => {
                        try {
                            const idx = params.dataIndex;
                            const item = window.charts.upChartData && window.charts.upChartData[idx];
                            if (!item) return;
                            // find marker for this row
                            const entry = dataStore.shelter.find(d => d.row === item._row);
                            if (entry) {
                                showShelterDetails(entry.row, entry.marker);
                            } else {
                                // fallback: show details without marker
                                showShelterDetails(item._row, null);
                            }
                            // re-render chart centered on this selection
                            try { updateComparisonChart(item._row); } catch(e){/* ignore */}
                        } catch (e) { console.warn('upChart click inner', e); }
                    });
                } catch(e){ console.warn('attach upChart click', e); }
            } catch (e) { console.warn('updateComparisonChart error', e); }
        }

        // Show shelter details in the right-middle card and open popup + pan map
        function showShelterDetails(row, marker) {
            // Middle status card removed — show details via marker popup and flyTo instead.
            const name = row.name || row.number || row.address || '避難所';
            console.debug('showShelterDetails for', name);
            try {
                if (marker) {
                    marker.togglePopup();
                    const lnglat = marker.getLngLat();
                    map.flyTo({ center: [lnglat.lng, lnglat.lat], zoom: 15 });
                }
            } catch (e) { console.warn('showShelterDetails error', e); }
        }

        // Render shelter list with search and hazard filter
        function renderShelterList() {
            const container = document.getElementById('rightDown-right');
            if (!container) return;
            const data = dataStore.shelter.slice().map(d=>d);

            // build controls
            container.innerHTML = `
                <div style="font-weight:700;color:#F39C12;margin-bottom:6px">避難所列表（依容納人數）</div>
                <div style="margin-bottom:6px"><input id="shelter-search" placeholder="搜尋名稱或地址" style="width:60%;padding:6px;border:1px solid #e6eef6;border-radius:6px" /> <label style="margin-left:6px"><input id="filter-flood" type="checkbox"> 只顯示支援水災</label></div>
                <div id="shelter-list" style="max-height:220px;overflow:auto;padding-right:6px"></div>
            `;

            const listEl = document.getElementById('shelter-list');
            const searchEl = document.getElementById('shelter-search');
            const filterFlood = document.getElementById('filter-flood');

            function renderList() {
                const q = (searchEl.value||'').trim().toLowerCase();
                const onlyFlood = filterFlood.checked;
                // map to objects with row and marker and numeric people
                const rows = data.map(d => ({ row: d.row, marker: d.marker, people: parseInt(String(d.row.people||'0').replace(/,/g,''))||0 }));
                let filtered = rows.filter(r => {
                    if (onlyFlood) {
                        const v = String(r.row.forFlooding||'').trim().toUpperCase();
                        if (!(v==='Y' || v==='YES' || v==='TRUE' || v==='可')) return false;
                    }
                    if (!q) return true;
                    const name = (r.row.name||r.row.number||r.row.address||'').toString().toLowerCase();
                    return name.indexOf(q) !== -1;
                });
                filtered.sort((a,b)=> b.people - a.people);

                listEl.innerHTML = '';
                filtered.forEach(item => {
                    const name = item.row.name || item.row.number || (item.row.address?item.row.address.split(',')[0]:'避難所');
                    const li = document.createElement('div');
                    li.style.padding = '8px';
                    li.style.borderBottom = '1px solid #f0f4f8';
                    li.style.cursor = 'pointer';
                    li.innerHTML = `<div style="font-weight:700">${name}</div><div style="font-size:12px;color:#666">容納: ${item.people}</div>`;
                    li.addEventListener('click', ()=>{
                        showShelterDetails(item.row, item.marker);
                        try { updateComparisonChart(item.row); } catch(e){console.warn(e)}
                    });
                    listEl.appendChild(li);
                });
            }

            searchEl.addEventListener('input', renderList);
            filterFlood.addEventListener('change', renderList);
            renderList();
        }

        // Setup layer toggle buttons that show/hide marker groups and update icon appearance
        function setupLayerToggles(){
            // helper: show/hide markers by key
            function setLayerVisible(key, visible){
                (markerStore[key]||[]).forEach(m=>{
                    try{ if(visible) m.addTo(map); else m.remove(); }catch(e){console.warn('marker toggle error',e)}
                });
            }

            // wire up buttons with .layer-toggle
            const buttons = document.querySelectorAll('.layer-toggle');
            buttons.forEach(btn => {
                const key = btn.getAttribute('data-layer');
                if(!key) return;
                // initial state: pressed -> visible
                const pressed = btn.getAttribute('aria-pressed') !== 'false';
                if(!pressed) btn.classList.add('off');
                setLayerVisible(key, pressed);

                btn.addEventListener('click', ()=>{
                    const cur = btn.getAttribute('aria-pressed') === 'true';
                    const next = !cur;
                    btn.setAttribute('aria-pressed', String(next));
                    btn.classList.toggle('off', !next);
                    setLayerVisible(key, next);
                });
            });
        }

        // Wire the static tabs + panels that exist in the HTML
        function setupTabs(){
            try{
                var tabWrap = document.querySelector('.right-tabs');
                if(!tabWrap) return;
                var buttons = tabWrap.querySelectorAll('button');
                buttons.forEach(function(b){
                    b.addEventListener('click', function(){
                        buttons.forEach(function(x){ x.classList.remove('active'); });
                        b.classList.add('active');
                        var t = b.getAttribute('data-tab');
                        document.querySelectorAll('.panel').forEach(function(p){ p.classList.remove('active'); });
                        var target = document.getElementById('panel-'+t);
                        if (target) target.classList.add('active');
                        // resize charts after a short delay so containers are visible
                        setTimeout(function(){
                            try{ if(window.charts && window.charts.upChart) window.charts.upChart.resize(); }catch(e){}
                            try{ if(window.charts && window.charts.medChart) window.charts.medChart.resize(); }catch(e){}
                            try{ if(window._shelterPie) window._shelterPie.resize(); }catch(e){}
                        }, 250);
                    });
                });
            }catch(e){ console.warn('setupTabs error', e); }
        }

        // Small helper to evaluate truthy 'Y' variants
        function globalIsYes(v){ if(v===undefined||v===null) return false; const s=String(v).trim().toUpperCase(); return s==='Y'||s==='YES'||s==='TRUE'||s==='可'; }

        // Render pie chart counting shelters by supported disaster types
        function renderShelterTypePie(){
            try{
                const counts = { 水災:0, 地震:0, 土石流:0, 海嘯:0 };
                (dataStore.shelter||[]).forEach(d=>{
                    const r = d.row || {};
                    if (globalIsYes(r.forFlooding)) counts.水災++;
                    if (globalIsYes(r.forEarthquake)) counts.地震++;
                    if (globalIsYes(r.forMudslide)) counts.土石流++;
                    if (globalIsYes(r.forTsunami)) counts.海嘯++;
                });
                const pieData = Object.keys(counts).map(k=>({ name:k, value: counts[k] }));
                // init chart
                const el = document.getElementById('shelterPie');
                if(!el) return;
                window._shelterPie = window._shelterPie || echarts.init(el);
                const option = {
                    tooltip: { trigger: 'item' },
                    legend: { orient: 'vertical', left: 'left' },
                    series: [{
                        name: '避難所數量',
                        type: 'pie',
                        radius: ['40%', '70%'],
                        avoidLabelOverlap: false,
                        itemStyle: { borderRadius: 6, borderColor: '#fff', borderWidth: 2 },
                        label: { show: false, position: 'center' },
                        emphasis: { label: { show: true, fontSize: '16', fontWeight: 'bold' } },
                        labelLine: { show: false },
                        data: pieData
                    }]
                };
                window._shelterPie.setOption(option);
            }catch(e){ console.warn('renderShelterTypePie error', e); }
        }

    // Initialize map and plotting when page loads
    document.addEventListener('DOMContentLoaded', ()=>{ setupTabs(); createMapAndPlotCSV(); });
    </script>
</body>
</html>
