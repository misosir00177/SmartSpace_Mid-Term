<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>Weather Visualization</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <!-- (ECharts removed — this page now focuses on plotting CSV-based shelter/medical/water points) -->
    <!-- ECharts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
    <!-- Mapbox -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", "Noto Sans TC", sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #f9f9f9;
        }

        #mainChart {
            flex: 1.6;
            height: 100%;
            border-right: 2px solid #e0e0e0;
        }

        #rightUpChart, #rightDown {
            width: 100%;
            padding: 10px;
        }

        /* give more vertical room to the top chart and allow the bottom panel to expand */
        #rightUpChart { height: 260px; }
        #rightDown { flex: 1; }
        #rightDown-chart { height: 100%; }
        #rightDown {
            display: flex;
            gap: 10px;
        }

        #rightDown-left, #rightDown-right {
            flex: 1;
            height: 100%;
            border-radius: 12px;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        #rightUpChart {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 10px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        .map-title {
            position: absolute;
            top: 15px;
            left: 20px;
            background: rgba(255, 255, 255, 0.85);
            padding: 6px 14px;
            border-radius: 8px;
            font-weight: 600;
            color: #A41623;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>

<body>
    <div id="mainChart">
        <div class="map-title">避難資源地圖</div>
    </div>

    <div style="flex: 1; display: flex; flex-direction: column; background: #f5f5f7; padding: 10px; gap:10px;">
        <div style="padding:8px 12px;">
            <h2 style="margin:0 0 8px 0;color:#2b6ea3;font-size:18px">避難資訊地圖</h2>
            <label style="margin-right:10px"><input id="toggle-water" type="checkbox" checked> 飲水機</label>
            <label style="margin-right:10px"><input id="toggle-shelter" type="checkbox" checked> 避難所</label>
            <label style="margin-right:10px"><input id="toggle-med" type="checkbox" checked> 醫療院所</label>
            <hr style="margin-top:8px;border:none;border-top:1px solid #e6eef6">
        </div>

        <div id="rightUpChart"></div>

        <div id="rightDown" style="display:flex;gap:10px;">
            <div id="rightDown-chart" style="flex:1;padding:12px;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,0.04)"></div>
        </div>
    </div>

    <script>
        // This page now focuses on plotting CSV-sourced points (避難為主題).
        let map = null;

        function loadCSV(path) {
            console.log('Attempting to load CSV:', path);
            return fetch(path)
                .then(res => {
                    if (!res.ok) throw new Error('Failed to fetch ' + path + ' (' + res.status + ')');
                    return res.text();
                })
                .then(text => {
                    try {
                        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true }).data;
                        console.log(`Parsed ${parsed.length} rows from ${path}`);
                        return parsed;
                    } catch (e) {
                        console.error('PapaParse error for', path, e);
                        throw e;
                    }
                });
        }

    // Add markers from CSV rows. label chooses color & popup title.
    // This function now also stores markers in global arrays so they can be toggled on/off.
    const markerStore = { shelter: [], med: [], water: [] };
    // dataStore keeps pairs of { row, marker } so UI lists can access marker for flyTo/openPopup
    const dataStore = { shelter: [], med: [], water: [] };
        function addCSVMarkers(rows, label) {
            if (!map || !rows) return [];
            const bounds = new mapboxgl.LngLatBounds();
            rows.forEach(row => {
                // Parse floats from common column names
                let lng = parseFloat(row.lng || row.LNG || row.Long || row.longitude || '');
                let lat = parseFloat(row.lat || row.LAT || row.Lat || row.latitude || '');

                // If parsing yields NaN, try alternative columns or trimmed values
                if (Number.isNaN(lng) && row.longitude) lng = parseFloat(row.longitude.trim());
                if (Number.isNaN(lat) && row.latitude) lat = parseFloat(row.latitude.trim());

                // Some CSVs have columns mislabeled: values may be in lat,lng order.
                // Detect and swap when needed (e.g., latitude outside [-90,90] or longitude outside [-180,180]).
                const isLatValid = !Number.isNaN(lat) && lat >= -90 && lat <= 90;
                const isLngValid = !Number.isNaN(lng) && lng >= -180 && lng <= 180;
                if (!isLatValid && isLngValid) {
                    // maybe swapped
                    console.warn('Detected invalid lat; attempting swap for row:', row);
                    const maybeLat = lng;
                    const maybeLng = lat;
                    if (!Number.isNaN(maybeLat) && maybeLat >= -90 && maybeLat <= 90 && !Number.isNaN(maybeLng) && maybeLng >= -180 && maybeLng <= 180) {
                        lat = maybeLat;
                        lng = maybeLng;
                        console.log('Swapped lat/lng for row — new lat:', lat, 'new lng:', lng);
                    } else {
                        // still invalid after swap — skip
                        console.error('Invalid coordinates after swap attempt, skipping row:', row);
                        return;
                    }
                }

                // final validation
                if (Number.isNaN(lng) || Number.isNaN(lat) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    // skip invalid coordinates
                    console.warn('Skipping row with invalid coordinates:', { lng, lat, row });
                    return;
                }

                //SECTION color by label
                let color = '#2ca02c'; // default (避難)
                if (/醫療|hospital|clinic/i.test(label)) color = '#A41623';
                if (/飲水|water/i.test(label)) color = '#1f77b4';

                const marker = new mapboxgl.Marker({ color })
                    .setLngLat([lng, lat])
                    .addTo(map);

                // wire marker click to show details and update comparison chart
                try {
                    const el = marker.getElement();
                    el.addEventListener('click', (e) => {
                        // call details + comparison
                        showShelterDetails(row, marker);
                        try { updateComparisonChart(row); } catch(err){console.warn(err)}
                    });
                } catch (e) { /* ignore if can't attach */ }

                const isMedical = /醫療|hospital|clinic/i.test(label);
                const title = isMedical ? (row.placeName || row.name || row.address || label) : (row.name || row.number || row.address || label || '地點');
                const info = [];
                info.push('類型: ' + label);
                if (row.address) info.push('地址: ' + row.address);
                // phone may be present for both medical and other datasets
                if (row.phone || row.call) info.push('電話: ' + (row.phone || row.call));
                if (row.openingHour) info.push('營業/開放: ' + row.openingHour);

                // Medical-specific fields: normalBed, icuBed, placeName
                if (isMedical) {
                    if (row.normalBed !== undefined && row.normalBed !== '') info.push('一般病床: ' + row.normalBed);
                    if (row.icuBed !== undefined && row.icuBed !== '') info.push('加護病床: ' + row.icuBed);
                    
                }

                // If shelter-specific fields exist, show only applicable hazard types (those marked 'Y')
                function yn(val){
                    if (!val) return '-';
                    const v = String(val).trim().toUpperCase();
                    if (v === 'Y' || v === 'YES' || v === 'TRUE' || v === '可') return '可';
                    if (v === 'N' || v === 'NO' || v === 'FALSE' || v === '否') return '否';
                    return val;
                }

                // For shelters, collect only the hazards that are applicable (Y)
                if (!isMedical) {
                    const hazards = [];
                    const isYes = v => {
                        if (v === undefined || v === null) return false;
                        const s = String(v).trim().toUpperCase();
                        return s === 'Y' || s === 'YES' || s === 'TRUE' || s === '可';
                    };
                    if (isYes(row.forFlooding)) hazards.push('水災');
                    if (isYes(row.forEarthquake)) hazards.push('地震');
                    if (isYes(row.forMudslide)) hazards.push('土石流');
                    if (isYes(row.forTsunami)) hazards.push('海嘯');

                    if (hazards.length > 0) {
                        info.push('適用避難類型: ' + hazards.join('、'));
                    }
                }

                if (row.people !== undefined && row.people !== '') info.push('容納人數: ' + row.people);

                const popupHtml = `<div style="font-size:13px"><div style="font-weight:700;color:${color};margin-bottom:4px">${title}</div>${info.join('<br>')}</div>`;
                marker.setPopup(new mapboxgl.Popup({ offset: 12 }).setHTML(popupHtml));
                bounds.extend([lng, lat]);

                // store marker and row for toggling & UI
                const key = /醫療|hospital|clinic/i.test(label) ? 'med' : (/飲水|water/i.test(label) ? 'water' : 'shelter');
                markerStore[key].push(marker);
                dataStore[key].push({ row: row, marker: marker });
            });
            return bounds;
        }

        function createMapAndPlotCSV() {
            mapboxgl.accessToken = 'pk.eyJ1IjoiYmlhYm9ibyIsImEiOiJjamVvejdlNXQxZnBuMndtdWhiZHRuaTNpIn0.PIS9wtUxm_rz_IzF2WFD1g';
            map = new mapboxgl.Map({
                container: 'mainChart',
                style: 'mapbox://styles/mapbox/light-v11',
                center: [121.6405, 25.0768],
                zoom: 11
            });
            // Wait for map to be ready before adding markers
            map.on('load', () => {
                console.log('Map loaded — now loading CSVs');

                // --- Daan district mask + highlight setup ---
                const daanCoords = [[
                    [121.5250, 25.0000],
                    [121.5250, 25.0600],
                    [121.5650, 25.0600],
                    [121.5650, 25.0000],
                    [121.5250, 25.0000]
                ]];

                const daanPolygon = {
                    type: 'Feature',
                    properties: { name: '大安區' },
                    geometry: { type: 'Polygon', coordinates: daanCoords }
                };

                // world polygon outer ring
                const worldOuter = [
                    [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
                ];
                const maskPolygon = {
                    type: 'Feature',
                    properties: {},
                    geometry: { type: 'Polygon', coordinates: [worldOuter].concat(daanCoords) }
                };

                if (!map.getSource('daan-mask')) {
                    map.addSource('daan-mask', { type: 'geojson', data: maskPolygon });
                    map.addLayer({
                        id: 'mask-fill',
                        type: 'fill',
                        source: 'daan-mask',
                        layout: {},
                        paint: {
                            'fill-color': 'rgba(230,230,230,0.85)',
                            'fill-opacity': 1
                        }
                    });
                }

                if (!map.getSource('daan')) {
                    map.addSource('daan', { type: 'geojson', data: daanPolygon });
                    map.addLayer({
                        id: 'daan-fill',
                        type: 'fill',
                        source: 'daan',
                        layout: {},
                        paint: { 'fill-color': 'rgba(164,22,35,0.08)', 'fill-opacity': 1 }
                    });
                    map.addLayer({
                        id: 'daan-line',
                        type: 'line',
                        source: 'daan',
                        layout: { 'line-join': 'round', 'line-cap': 'round' },
                        paint: { 'line-color': '#A41623', 'line-width': 2, 'line-dasharray': [2,2] }
                    });
                }

                // --- end Daan setup ---

                Promise.all([
                    loadCSV('ref/DaanMedical.csv'),
                    loadCSV('ref/DaanShelter.csv'),
                    loadCSV('ref/DaanWaterserver.csv')
                ]).then(([med, shelter, water]) => {
                    // We care about shelters primarily, but still show medical & water points with different colors.
                    const boundsList = [];
                    const b1 = addCSVMarkers(shelter, '避難收容');
                    if (b1 && !b1.isEmpty()) boundsList.push(b1);
                    const b2 = addCSVMarkers(med, '醫療機構');
                    if (b2 && !b2.isEmpty()) boundsList.push(b2);
                    const b3 = addCSVMarkers(water, '飲水機');
                    if (b3 && !b3.isEmpty()) boundsList.push(b3);

                    // Fit map to combined bounds if any markers exist
                    if (boundsList.length > 0) {
                        const combined = boundsList.reduce((acc, b) => acc.extend(b), boundsList[0]);
                        map.fitBounds(combined, { padding: 40 });
                    } else {
                        console.warn('No marker bounds found — check parsed CSV rows and lng/lat columns');
                    }

                            // render charts & setup UI
                            try {
                                renderRightPanelCharts(med, shelter, water);
                                setupLayerToggles();
                                // render shelter list (uses dataStore populated by addCSVMarkers)
                                renderShelterList();
                            } catch (e) { console.error('Error rendering right panel', e); }
                }).catch(err => console.error('CSV load error', err));
            });
        }

        // Render the right-side charts and cards using ECharts + HTML
        function renderRightPanelCharts(med, shelter, water) {
            // RightUpChart: shelter capacity (top 5)
            try {
                // store parsed shelter data globally so we can update the chart on interactions
                window._shelterChartData = shelter.map(r => ({
                        name: r.name || r.number || (r.address ? r.address.split(',')[0] : '避難所'),
                        people: parseInt(String(r.people || '0').replace(/,/g, '')) || 0,
                        _row: r
                    })).sort((a, b) => b.people - a.people);

                    // initialize top chart and save reference globally for updates
                    window.charts = window.charts || {};
                    const upChart = echarts.init(document.getElementById('rightUpChart'));
                    window.charts.upChart = upChart;
                const upOption = {
                    title: { text: '避難所收容人數', left: 'center', textStyle: { color: '#A41623' } },
                    tooltip: {},
                    xAxis: { type: 'category', data: parsed.map(p => p.name), axisLabel: { rotate: 30 } },
                    yAxis: { type: 'value' },
                    series: [{ type: 'bar', data: parsed.map(p => p.people), itemStyle: { color: '#FFB081' } }]
                };
                upChart.setOption(upOption);
            } catch (e) { console.warn('shelter chart error', e); }

            // Middle status panel removed — no inline status card. Keep console info for debugging.
            try { console.debug('renderRightPanelCharts: shelter count', shelter.length); } catch(e){console.warn(e)}

            // RightDown-left: medical hospital bed counts (bar chart)
            try {
                const medParsed = med.map(r => ({
                    name: r.placeName || (r.address ? r.address.split(',')[0] : '醫療'),
                    normal: parseInt(String(r.normalBed||'0').replace(/,/g,'')) || 0,
                    icu: parseInt(String(r.icuBed||'0').replace(/,/g,'')) || 0
                })).sort((a,b)=> b.normal - a.normal).slice(0,6);

                const medChart = echarts.init(document.getElementById('rightDown-chart'));
                const medOption = {
                    title: { text: '醫療院所病床數', left: 'center', textStyle:{ color:'#A41623' } },
                    tooltip: { },
                    legend: { data: ['一般病床','加護病床'], bottom: 0 },
                    xAxis: { type: 'category', data: medParsed.map(m=>m.name), axisLabel:{rotate:30} },
                    yAxis: { type: 'value' },
                    series: [
                        { name: '一般病床', type: 'bar', data: medParsed.map(m=>m.normal), itemStyle:{ color:'#A41623'} },
                        { name: '加護病床', type: 'bar', data: medParsed.map(m=>m.icu), itemStyle:{ color:'#A416FF'} }
                    ]
                };
                medChart.setOption(medOption);
            } catch(e){ console.warn('medical chart error', e); }

            // When charts are first rendered, ensure the top chart shows default ordering
            try { if (window.charts && window.charts.upChart) {
                // default: show top 6 shelters
                updateComparisonChart();
            }} catch(e){console.warn(e)}
        }

        // Update the top chart to compare a selected shelter against others.
        // If selectedRow is undefined, show the default top N list.
        function updateComparisonChart(selectedRow) {
            try {
                const upChart = window.charts && window.charts.upChart;
                if (!upChart || !window._shelterChartData) return;

                const all = window._shelterChartData.slice();
                const selectedName = (selectedRow && (selectedRow.name || selectedRow.number || selectedRow.address)) || null;

                // If a specific row is selected, put it first and then top others (excluding it)
                let list = [];
                if (selectedName) {
                    const sel = all.find(a => {
                        const rname = String(a._row.name || a._row.number || a._row.address || '').toString();
                        return rname && rname.indexOf(selectedName) !== -1 || selectedName.indexOf(rname) !== -1;
                    }) || all.find(a => String(a._row.name||'') === selectedName);
                    if (sel) {
                        list.push(sel);
                        // add next top 5 others
                        const others = all.filter(a => a !== sel).slice(0,5);
                        list = list.concat(others);
                    } else {
                        // fallback to default
                        list = all.slice(0,6);
                    }
                } else {
                    list = all.slice(0,6);
                }

                const names = list.map(l => l.name);
                const values = list.map(l => l.people);

                // color first bar differently if it's the selected one
                const colors = list.map((l, idx) => idx===0 && selectedName ? '#2fa01a' : '#7aff7a');

                const option = {
                    title: { text: '避難所收容人數（比較）', left: 'center', textStyle: { color: '#2ca02c' } },
                    tooltip: {},
                    xAxis: { type: 'category', data: names, axisLabel: { rotate: 30 } },
                    yAxis: { type: 'value' },
                    series: [{ type: 'bar', data: values, itemStyle: { color: function(params){ return colors[params.dataIndex]; } } }]
                };
                upChart.setOption(option, true);
                // store currently-displayed data so clicks can map back to rows
                window.charts = window.charts || {};
                window.charts.upChartData = list;

                // attach click handler: use dataIndex to find the clicked shelter and fly to it
                try {
                    upChart.off('click');
                    upChart.on('click', params => {
                        try {
                            const idx = params.dataIndex;
                            const item = window.charts.upChartData && window.charts.upChartData[idx];
                            if (!item) return;
                            // find marker for this row
                            const entry = dataStore.shelter.find(d => d.row === item._row);
                            if (entry) {
                                showShelterDetails(entry.row, entry.marker);
                            } else {
                                // fallback: show details without marker
                                showShelterDetails(item._row, null);
                            }
                            // re-render chart centered on this selection
                            try { updateComparisonChart(item._row); } catch(e){/* ignore */}
                        } catch (e) { console.warn('upChart click inner', e); }
                    });
                } catch(e){ console.warn('attach upChart click', e); }
            } catch (e) { console.warn('updateComparisonChart error', e); }
        }

        // Show shelter details in the right-middle card and open popup + pan map
        function showShelterDetails(row, marker) {
            // Middle status card removed — show details via marker popup and flyTo instead.
            const name = row.name || row.number || row.address || '避難所';
            console.debug('showShelterDetails for', name);
            try {
                if (marker) {
                    marker.togglePopup();
                    const lnglat = marker.getLngLat();
                    map.flyTo({ center: [lnglat.lng, lnglat.lat], zoom: 15 });
                }
            } catch (e) { console.warn('showShelterDetails error', e); }
        }

        // Render shelter list with search and hazard filter
        function renderShelterList() {
            const container = document.getElementById('rightDown-right');
            if (!container) return;
            const data = dataStore.shelter.slice().map(d=>d);

            // build controls
            container.innerHTML = `
                <div style="font-weight:700;color:#F39C12;margin-bottom:6px">避難所列表（依容納人數）</div>
                <div style="margin-bottom:6px"><input id="shelter-search" placeholder="搜尋名稱或地址" style="width:60%;padding:6px;border:1px solid #e6eef6;border-radius:6px" /> <label style="margin-left:6px"><input id="filter-flood" type="checkbox"> 只顯示支援水災</label></div>
                <div id="shelter-list" style="max-height:220px;overflow:auto;padding-right:6px"></div>
            `;

            const listEl = document.getElementById('shelter-list');
            const searchEl = document.getElementById('shelter-search');
            const filterFlood = document.getElementById('filter-flood');

            function renderList() {
                const q = (searchEl.value||'').trim().toLowerCase();
                const onlyFlood = filterFlood.checked;
                // map to objects with row and marker and numeric people
                const rows = data.map(d => ({ row: d.row, marker: d.marker, people: parseInt(String(d.row.people||'0').replace(/,/g,''))||0 }));
                let filtered = rows.filter(r => {
                    if (onlyFlood) {
                        const v = String(r.row.forFlooding||'').trim().toUpperCase();
                        if (!(v==='Y' || v==='YES' || v==='TRUE' || v==='可')) return false;
                    }
                    if (!q) return true;
                    const name = (r.row.name||r.row.number||r.row.address||'').toString().toLowerCase();
                    return name.indexOf(q) !== -1;
                });
                filtered.sort((a,b)=> b.people - a.people);

                listEl.innerHTML = '';
                filtered.forEach(item => {
                    const name = item.row.name || item.row.number || (item.row.address?item.row.address.split(',')[0]:'避難所');
                    const li = document.createElement('div');
                    li.style.padding = '8px';
                    li.style.borderBottom = '1px solid #f0f4f8';
                    li.style.cursor = 'pointer';
                    li.innerHTML = `<div style="font-weight:700">${name}</div><div style="font-size:12px;color:#666">容納: ${item.people}</div>`;
                    li.addEventListener('click', ()=>{
                        showShelterDetails(item.row, item.marker);
                        try { updateComparisonChart(item.row); } catch(e){console.warn(e)}
                    });
                    listEl.appendChild(li);
                });
            }

            searchEl.addEventListener('input', renderList);
            filterFlood.addEventListener('change', renderList);
            renderList();
        }

        // Setup checkbox toggles to show/hide marker groups
        function setupLayerToggles(){
            const toggle = (id, key)=>{
                const cb = document.getElementById(id);
                if(!cb) return;
                cb.addEventListener('change', ()=>{
                    const visible = cb.checked;
                    markerStore[key].forEach(m=>{
                        try{
                            if(visible) m.addTo(map); else m.remove();
                        }catch(e){console.warn('marker toggle error',e)}
                    });
                });
            };
            toggle('toggle-water','water');
            toggle('toggle-shelter','shelter');
            toggle('toggle-med','med');
        }

        // Initialize map and plotting when page loads
        document.addEventListener('DOMContentLoaded', createMapAndPlotCSV);
    </script>
</body>
</html>
